C#5.0	Mono JIT compiler version 6.8.0.105 (Debian 6.8.0.105+dfsg-2 Wed Feb 26 23:41:24 UTC 2020)	ã‚¿ã‚¤ãƒ ãƒªãƒŸãƒƒãƒˆ5.0s ãƒ¡ãƒ¢ãƒªåˆ¶é™512MB	
<ç·å’Œã®è¨ˆç®—>75ç‚¹
using System;

class Program
{
    static void Main()
    {
        // å…¥åŠ›ã‚’å—ã‘å–ã‚‹
        string[] input = Console.ReadLine().Split();
        ulong A = ulong.Parse(input[0]);
        ulong B = ulong.Parse(input[1]);

        // A ã‹ã‚‰ B ã¾ã§ã®å’Œã‚’æ±‚ã‚ã‚‹å¼: (A + B) * (B - A + 1) / 2
        ulong count = B - A + 1; // B - A + 1 ã‚’æœ€åˆã«è¨ˆç®—
        ulong sum = (A + B) * count / 2;

        // çµæœã‚’å‡ºåŠ›
        Console.WriteLine(sum);
    }
}

/*2ã¤ã®æ•´æ•°A, B ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚
1ã‹ã‚‰Nã¾ã§ã®å’Œã¯ã€N(N+1)/2ã§æ±‚ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ ã¾ãŸã€A < B ã§ã‚ã‚‹ã“ã¨ã‹ã‚‰ A ã‹ã‚‰ B ã¾ã§ã®å’Œã¯ã€ (1ã‹ã‚‰Bã¾ã§ã®å’Œ) - (1ã‹ã‚‰A-1ã¾ã§ã®å’Œ) ã§æ±‚ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ç«‹å¼ã‚’è¡Œã†ã¨ã€ B(B+1)/2-(A-1)A/2 ã¨ãªã‚‹ã®ã§ã€å¼å¤‰å½¢ã‚’è¡Œã†ã“ã¨ã§ã€(A+B)(B-A+1)/2 ã‚’å°å‡ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚*/

ä»¥ä¸‹ã¯C#5.0å¯¾å¿œã€€100ç‚¹
using System;
using System.Collections.Generic;
using System.Text;

class Program
{
    static void Main()
    {
        string[] s = Console.ReadLine().Split();
        BigNum A = new BigNum(s[0]);
        BigNum B = new BigNum(s[1]);

        BigNum one = new BigNum("1");
        BigNum count = B - A + one;
        BigNum sum = (A + B) * count / new BigNum("2");

        Console.WriteLine(sum.ToString());
    }
}

class BigNum
{
    const int BASE = 10000;
    const int WIDTH = 4;
    List<int> digits = new List<int>();

    public BigNum(string s)
    {
        for (int i = s.Length; i > 0; i -= WIDTH)
        {
            int start = Math.Max(0, i - WIDTH);
            digits.Add(int.Parse(s.Substring(start, i - start)));
        }
        Normalize();
    }

    public BigNum(List<int> d)
    {
        digits = d;
        Normalize();
    }

    private void Normalize()
    {
        while (digits.Count > 1 && digits[digits.Count - 1] == 0)
            digits.RemoveAt(digits.Count - 1);
    }

    public static BigNum operator +(BigNum a, BigNum b)
    {
        List<int> res = new List<int>();
        int carry = 0, i = 0;
        while (i < a.digits.Count || i < b.digits.Count || carry > 0)
        {
            int sum = carry;
            if (i < a.digits.Count) sum += a.digits[i];
            if (i < b.digits.Count) sum += b.digits[i];
            res.Add(sum % BASE);
            carry = sum / BASE;
            i++;
        }
        return new BigNum(res);
    }

    public static BigNum operator -(BigNum a, BigNum b)
    {
        List<int> res = new List<int>();
        int carry = 0;
        for (int i = 0; i < a.digits.Count; i++)
        {
            int sub = a.digits[i] - carry - (i < b.digits.Count ? b.digits[i] : 0);
            if (sub < 0)
            {
                sub += BASE;
                carry = 1;
            }
            else carry = 0;
            res.Add(sub);
        }
        return new BigNum(res);
    }

    public static BigNum operator *(BigNum a, BigNum b)
    {
        List<int> res = new List<int>(new int[a.digits.Count + b.digits.Count]);
        for (int i = 0; i < a.digits.Count; i++)
        {
            for (int j = 0; j < b.digits.Count; j++)
            {
                long tmp = (long)a.digits[i] * b.digits[j] + res[i + j];
                res[i + j] = (int)(tmp % BASE);
                res[i + j + 1] += (int)(tmp / BASE);
            }
        }
        return new BigNum(res);
    }

    public static BigNum operator /(BigNum a, BigNum b)
    {
        if (b.ToString() != "2") throw new NotSupportedException("Only division by 2 supported.");
        List<int> res = new List<int>(a.digits);
        int carry = 0;
        for (int i = res.Count - 1; i >= 0; i--)
        {
            long cur = (long)res[i] + carry * (long)BASE;
            res[i] = (int)(cur / 2);
            carry = (int)(cur % 2);
        }
        return new BigNum(res);
    }

    public override string ToString()
    {
        StringBuilder sb = new StringBuilder();
        sb.Append(digits[digits.Count - 1]);
        for (int i = digits.Count - 2; i >= 0; i--)
            sb.Append(digits[i].ToString().PadLeft(WIDTH, '0'));
        return sb.ToString();
    }
}
/*ã€ç›®çš„ã€‘
2ã¤ã®æ•´æ•° A, B ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã€A + (A+1) + (A+2) + ... + B ã®ç·å’Œã‚’ æ­£ç¢ºã«æ±‚ã‚ãŸã„ã€‚
åˆ¶ç´„ï¼š
0 â‰¦ A â‰¦ B < 10^11
ã¤ã¾ã‚Šã€ç­”ãˆãŒ 10^19 ã‚’è¶…ãˆã‚‹å ´åˆã‚‚ã‚ã‚‹ï¼ˆulong ã‚„ long ã§ã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ï¼‰
â†’ å¤šå€é•·æ•´æ•°ï¼ˆBigNumï¼‰ã‚’è‡ªä½œã—ã¦è¨ˆç®—ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
æ•°åˆ— A ã‹ã‚‰ B ã¾ã§ã®ç·å’Œã¯ã€ä»¥ä¸‹ã®å¼ã§æ±‚ã¾ã‚Šã¾ã™ï¼š(A + B) * (B - A + 1) / 2
ã“ã‚Œã¯ã€
é …æ•°ãŒ (B - A + 1) å€‹ã‚ã‚Šå„é …ã®å¹³å‡å€¤ãŒ (A + B) / 2ã¨ã„ã†ç†ç”±ã‹ã‚‰å°ã‹ã‚Œã‚‹å…¬å¼ã§ã™ã€‚
å…¥åŠ›ã‹ã‚‰ A, B ã‚’èª­ã¿å–ã‚Šã€æ–‡å­—åˆ—ã¨ã—ã¦ BigNum ã«å¤‰æ›ã€‚count = B - A + 1ï¼ˆé …æ•°ï¼‰ sum = (A + B) * count / 2ï¼ˆç·å’Œï¼‰ æœ€çµ‚çš„ãª sum ã‚’æ–‡å­—åˆ—ã¨ã—ã¦è¡¨ç¤ºã€‚
å¤šå€é•·æ•´æ•°ã‚’ 4æ¡å˜ä½ã®é…åˆ—ï¼ˆList<int>ï¼‰ã§è¡¨ç¾ã—ã¦ãŠã‚Šã€å„æ¡ã¯ 10000 æœªæº€ã®æ•´æ•°ã¨ã—ã¾ã™ã€‚

ğŸ“¥ new BigNum("12345678") ã®ã‚ˆã†ã«ä½œã‚‹ã¨â€¦
å†…éƒ¨çš„ã«ã¯ï¼š[5678, 1234]  // ä¸‹ä½æ¡ã‹ã‚‰æ ¼ç´
C# 5.0 / Mono ç’°å¢ƒã§ã‚‚å®Œå…¨å¯¾å¿œï¼ˆBigInteger ãªã—ï¼‰
æ¡æ•°ã«åˆ¶é™ãªã—ï¼ˆç†è«–ä¸Šã¯10^100ã§ã‚‚ã„ã‘ã‚‹ï¼‰
æå‡ºç’°å¢ƒã§ 100ç‚¹ãŒå–ã‚Œã‚‹ãƒ¬ãƒ™ãƒ«ã®å …å®Ÿãªå®Ÿè£… */

<ifã‚’ä½¿ã„ã¾ã™ã‹ï¼Ÿä¸‰é …æ¼”ç®—å­ã‚’ä½¿ã„ã¾ã™ã‹ï¼Ÿ>
using System;

class Program
{
    static void Main()
    {
        // 1è¡Œç›®: æ•´æ•° a
        string line1 = Console.ReadLine();
        int a;
        if (int.TryParse(line1, out a))
        {
            Console.WriteLine(a > 0 ? "plus" : line1);
        }
        else
        {
            Console.WriteLine(line1);
        }

        // 2è¡Œç›®: æ–‡å­—åˆ— b
        string b = Console.ReadLine();
        Console.WriteLine(b == "hoge" ? "yes" : b);

        // 3è¡Œç›®: æ–‡å­—åˆ— c
        string c = Console.ReadLine();
        Console.WriteLine(c.Length == 10 ? "ten" : c);

        // 4è¡Œç›®: æ–‡å­—åˆ— d
        string d = Console.ReadLine();
        int xIndex = d.IndexOf('x');
        Console.WriteLine(xIndex >= 0 ? xIndex.ToString() : "nothing");

        // 5è¡Œç›®: æ–‡å­—åˆ— e
        string e = Console.ReadLine();
        Console.WriteLine(e.Length == 5 ? "five" : (e.Length > 0 ? e[0].ToString() : ""));
    }
}
/*ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€5è¡Œã®æ¨™æº–å…¥åŠ›ã‚’å—ã‘å–ã‚Šã€ãã‚Œãã‚Œã«å¯¾ã—ã¦æ¡ä»¶ã«åŸºã¥ã„ãŸå‡ºåŠ›ã‚’è¡Œã†ã‚‚ã®ã§ã™ã€‚
C# ã® Console.ReadLine() ã‚’ä½¿ã£ã¦æ¨™æº–å…¥åŠ›ã‹ã‚‰1è¡Œãšã¤èª­ã¿è¾¼ã¿ã€å„è¡Œã®å‡¦ç†ã‚’é †ã«è¡Œã„ã¾ã™ã€‚
line1 ã«æ¨™æº–å…¥åŠ›ã®1è¡Œç›®ï¼ˆæ•´æ•° aï¼‰ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚
int.TryParse() ã‚’ä½¿ã£ã¦æ•´æ•°ã«å¤‰æ›ã§ãã‚‹ã‹ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚
æˆåŠŸã™ã‚Œã°ã€a ã«æ•´æ•°å€¤ãŒä»£å…¥ã•ã‚Œã¾ã™ã€‚
a ãŒ 0 ã‚ˆã‚Šå¤§ãã‘ã‚Œã° "plus" ã‚’å‡ºåŠ›ã€‚
ãã†ã§ãªã‘ã‚Œã°ã€å…¥åŠ›ã•ã‚ŒãŸæ–‡å­—åˆ—ãã®ã¾ã¾ï¼ˆline1ï¼‰ã‚’å‡ºåŠ›ã€‚
â€» TryParse ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ã§ã€æ•´æ•°ã§ãªã„å…¥åŠ›ã«ã‚‚è€æ€§ãŒã‚ã‚Šã¾ã™ã€‚
b ã«2è¡Œç›®ã®å…¥åŠ›æ–‡å­—åˆ—ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚
ãã®æ–‡å­—åˆ—ãŒ "hoge" ã¨å®Œå…¨ä¸€è‡´ã™ã‚Œã° "yes" ã‚’å‡ºåŠ›ã€‚
ä¸€è‡´ã—ãªã‘ã‚Œã°ã€å…¥åŠ›ã•ã‚ŒãŸæ–‡å­—åˆ—ã‚’ãã®ã¾ã¾å‡ºåŠ›ã—ã¾ã™ã€‚
c ã«3è¡Œç›®ã®å…¥åŠ›ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚
c.Length == 10 ã§æ–‡å­—æ•°ãŒ10æ–‡å­—ã¡ã‚‡ã†ã©ã‹ã‚’åˆ¤å®šã€‚
10æ–‡å­—ãªã‚‰ "ten" ã‚’å‡ºåŠ›ã€‚
ãã‚Œä»¥å¤–ãªã‚‰å…ƒã®æ–‡å­—åˆ—ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚
d ã«4è¡Œç›®ã®å…¥åŠ›ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚
IndexOf('x') ã§ã€**æœ€åˆã«å‡ºã¦ãã‚‹ 'x' ã®ä½ç½®ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰**ã‚’å–å¾—ã€‚
'x' ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€IndexOf ã¯ -1 ã‚’è¿”ã—ã¾ã™ã€‚
'x' ãŒå«ã¾ã‚Œã¦ã„ã‚Œã°ã€ãã®ä½ç½®ï¼ˆ0å§‹ã¾ã‚Šï¼‰ã‚’å‡ºåŠ›ã€‚
å«ã¾ã‚Œã¦ã„ãªã‘ã‚Œã° "nothing" ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚
e ã«5è¡Œç›®ã®å…¥åŠ›ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚
e.Length == 5 ã§ã¡ã‚‡ã†ã©5æ–‡å­—ãªã‚‰ "five" ã‚’å‡ºåŠ›ã€‚
ãã†ã§ãªã‘ã‚Œã°ã€e[0] ã§1æ–‡å­—ç›®ã‚’å–å¾—ã—ã¦å‡ºåŠ›ã€‚
æ–‡å­—åˆ—ãŒç©ºã ã£ãŸå ´åˆã«å‚™ãˆã¦ e.Length > 0 ã§ãƒã‚§ãƒƒã‚¯ã—ã€ç©ºãªã‚‰ç©ºæ–‡å­—ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚*/

<æ•°ã®ä¸¦ã³æ›¿ãˆ>
using System;
using System.Collections.Generic;

public class Program
{
    public static void Main()
    {
        // å…¥åŠ›ã•ã‚ŒãŸæœ€åˆã®è¡Œã‚’èª­ã¿å–ã‚Šã€nã‚’å–å¾—
        string line = Console.ReadLine();
        int n = int.Parse(line);

        // æ•°å€¤ã‚’æ ¼ç´ã™ã‚‹ãƒªã‚¹ãƒˆ
        List<int> numbers = new List<int>();

        // nå€‹ã®æ•°å€¤ã‚’èª­ã¿å–ã‚Šã€ãƒªã‚¹ãƒˆã«è¿½åŠ 
        for (int i = 0; i < n; i++)
        {
            line = Console.ReadLine();
            int number = int.Parse(line);
            numbers.Add(number);
        }

        // æ˜‡é †ã«ã‚½ãƒ¼ãƒˆ
        numbers.Sort();

        // çµæœã‚’1è¡Œãšã¤å‡ºåŠ›
        foreach (int num in numbers)
        {
            Console.WriteLine(num);
        }
    }
}
/*ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ã¾ãšæœ€åˆã«ä¸ãˆã‚‰ã‚ŒãŸæ­£ã®æ•´æ•° n ã‚’èª­ã¿å–ã‚Šã€ãã®ã‚ã¨ã«ç¶šã n å€‹ã®æ•´æ•°ã‚’ å°ã•ã„é †ï¼ˆæ˜‡é †ï¼‰ ã«ä¸¦ã¹æ›¿ãˆã¦ã€1è¡Œãšã¤å‡ºåŠ›ã—ã¾ã™ã€‚
using System;
æ¨™æº–å…¥åŠ›ãƒ»å‡ºåŠ›ãªã©åŸºæœ¬æ©Ÿèƒ½ã‚’æä¾›ã™ã‚‹ Systemåå‰ç©ºé–“ ã‚’ä½¿ã†ãŸã‚ã®å®£è¨€ã§ã™ã€‚

using System.Collections.Generic;
List<T>ï¼ˆå‹•çš„é…åˆ—ã®ã‚ˆã†ãªã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ï¼‰ã‚’ä½¿ã†ãŸã‚ã«å¿…è¦ãªåå‰ç©ºé–“ã§ã™ã€‚

public class Program
Program ã¨ã„ã†åå‰ã®ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚C#ã§ã¯ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆï¼ˆå®Ÿè¡Œé–‹å§‹ç‚¹ï¼‰ã‚’å«ã‚€ã‚¯ãƒ©ã‚¹ãŒå¿…è¦ã§ã™ã€‚

public static void Main()
ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡ŒãŒå§‹ã¾ã‚‹ Main ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚static ãªã®ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚‰ãšã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚æˆ»ã‚Šå€¤ãŒãªã„ãŸã‚ void ã¨æ›¸ã‹ã‚Œã¦ã„ã¾ã™ã€‚

string line = Console.ReadLine();
æ¨™æº–å…¥åŠ›ï¼ˆã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚„ãƒ•ã‚¡ã‚¤ãƒ«ãªã©ï¼‰ã‹ã‚‰1è¡Œèª­ã¿å–ã£ã¦ã€æ–‡å­—åˆ—ã¨ã—ã¦å¤‰æ•° line ã«æ ¼ç´ã—ã¾ã™ã€‚

int n = int.Parse(line);
èª­ã¿å–ã£ãŸæ–‡å­—åˆ—ã‚’æ•´æ•°ã«å¤‰æ›ã—ã€å¤‰æ•° n ã«æ ¼ç´ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€å¾Œã«ç¶šãæ•°ã®å€‹æ•°ï¼ˆè¡Œæ•°ï¼‰ã‚’è¡¨ã—ã¾ã™ã€‚

List<int> numbers = new List<int>();
æ•´æ•°ã‚’è¤‡æ•°æ ¼ç´ã™ã‚‹ãŸã‚ã®ãƒªã‚¹ãƒˆã‚’ä½œæˆã—ã¦ã„ã¾ã™ã€‚List<int> ã¯é…åˆ—ã¨é•ã£ã¦è¦ç´ æ•°ã‚’å¾Œã‹ã‚‰è‡ªç”±ã«å¢—ã‚„ã›ã¾ã™ã€‚

for (int i = 0; i < n; i++)
n å›ç¹°ã‚Šè¿”ã™ãƒ«ãƒ¼ãƒ—ã§ã™ã€‚å…¥åŠ›ã•ã‚ŒãŸæ•´æ•°ã‚’é †ç•ªã«èª­ã¿å–ã‚Šã¾ã™

numbers.Sort();
ãƒªã‚¹ãƒˆã®ä¸­èº«ã‚’ æ˜‡é †ï¼ˆå°ã•ã„é †ï¼‰ ã«ä¸¦ã¹æ›¿ãˆã¾ã™ã€‚å†…éƒ¨çš„ã«ã¯ QuickSort ã‚„ IntroSort ãªã©ãŒä½¿ã‚ã‚Œã¾ã™ï¼ˆMonoç’°å¢ƒã«ã‚ˆã£ã¦å®Ÿè£…ã¯ç•°ãªã‚Šã¾ã™ï¼‰ã€‚

foreach (int num in numbers)
ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸæ•´æ•°ãƒªã‚¹ãƒˆã®å„è¦ç´ ã‚’1ã¤ãšã¤å–ã‚Šå‡ºã—ã¾ã™ã€‚*/

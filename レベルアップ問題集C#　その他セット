C#	Mono JIT compiler version 6.8.0.105 (Debian 6.8.0.105+dfsg-2 Wed Feb 26 23:41:24 UTC 2020)	ã‚¿ã‚¤ãƒ ãƒªãƒŸãƒƒãƒˆ5.0s ãƒ¡ãƒ¢ãƒªåˆ¶é™512MB	
<ç·å’Œã®è¨ˆç®—>75ç‚¹
using System;

class Program
{
    static void Main()
    {
        // å…¥åŠ›ã‚’å—ã‘å–ã‚‹
        string[] input = Console.ReadLine().Split();
        ulong A = ulong.Parse(input[0]);
        ulong B = ulong.Parse(input[1]);

        // A ã‹ã‚‰ B ã¾ã§ã®å’Œã‚’æ±‚ã‚ã‚‹å¼: (A + B) * (B - A + 1) / 2
        ulong count = B - A + 1; // B - A + 1 ã‚’æœ€åˆã«è¨ˆç®—
        ulong sum = (A + B) * count / 2;

        // çµæœã‚’å‡ºåŠ›
        Console.WriteLine(sum);
    }
}

/*2ã¤ã®æ•´æ•°A, B ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚
1ã‹ã‚‰Nã¾ã§ã®å’Œã¯ã€N(N+1)/2ã§æ±‚ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ ã¾ãŸã€A < B ã§ã‚ã‚‹ã“ã¨ã‹ã‚‰ A ã‹ã‚‰ B ã¾ã§ã®å’Œã¯ã€ (1ã‹ã‚‰Bã¾ã§ã®å’Œ) - (1ã‹ã‚‰A-1ã¾ã§ã®å’Œ) ã§æ±‚ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ç«‹å¼ã‚’è¡Œã†ã¨ã€ B(B+1)/2-(A-1)A/2 ã¨ãªã‚‹ã®ã§ã€å¼å¤‰å½¢ã‚’è¡Œã†ã“ã¨ã§ã€(A+B)(B-A+1)/2 ã‚’å°å‡ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚*/

ä»¥ä¸‹ã¯C#5.0å¯¾å¿œã€€100ç‚¹
using System;
using System.Collections.Generic;
using System.Text;

class Program
{
    static void Main()
    {
        string[] s = Console.ReadLine().Split();
        BigNum A = new BigNum(s[0]);
        BigNum B = new BigNum(s[1]);

        BigNum one = new BigNum("1");
        BigNum count = B - A + one;
        BigNum sum = (A + B) * count / new BigNum("2");

        Console.WriteLine(sum.ToString());
    }
}

class BigNum
{
    const int BASE = 10000;
    const int WIDTH = 4;
    List<int> digits = new List<int>();

    public BigNum(string s)
    {
        for (int i = s.Length; i > 0; i -= WIDTH)
        {
            int start = Math.Max(0, i - WIDTH);
            digits.Add(int.Parse(s.Substring(start, i - start)));
        }
        Normalize();
    }

    public BigNum(List<int> d)
    {
        digits = d;
        Normalize();
    }

    private void Normalize()
    {
        while (digits.Count > 1 && digits[digits.Count - 1] == 0)
            digits.RemoveAt(digits.Count - 1);
    }

    public static BigNum operator +(BigNum a, BigNum b)
    {
        List<int> res = new List<int>();
        int carry = 0, i = 0;
        while (i < a.digits.Count || i < b.digits.Count || carry > 0)
        {
            int sum = carry;
            if (i < a.digits.Count) sum += a.digits[i];
            if (i < b.digits.Count) sum += b.digits[i];
            res.Add(sum % BASE);
            carry = sum / BASE;
            i++;
        }
        return new BigNum(res);
    }

    public static BigNum operator -(BigNum a, BigNum b)
    {
        List<int> res = new List<int>();
        int carry = 0;
        for (int i = 0; i < a.digits.Count; i++)
        {
            int sub = a.digits[i] - carry - (i < b.digits.Count ? b.digits[i] : 0);
            if (sub < 0)
            {
                sub += BASE;
                carry = 1;
            }
            else carry = 0;
            res.Add(sub);
        }
        return new BigNum(res);
    }

    public static BigNum operator *(BigNum a, BigNum b)
    {
        List<int> res = new List<int>(new int[a.digits.Count + b.digits.Count]);
        for (int i = 0; i < a.digits.Count; i++)
        {
            for (int j = 0; j < b.digits.Count; j++)
            {
                long tmp = (long)a.digits[i] * b.digits[j] + res[i + j];
                res[i + j] = (int)(tmp % BASE);
                res[i + j + 1] += (int)(tmp / BASE);
            }
        }
        return new BigNum(res);
    }

    public static BigNum operator /(BigNum a, BigNum b)
    {
        if (b.ToString() != "2") throw new NotSupportedException("Only division by 2 supported.");
        List<int> res = new List<int>(a.digits);
        int carry = 0;
        for (int i = res.Count - 1; i >= 0; i--)
        {
            long cur = (long)res[i] + carry * (long)BASE;
            res[i] = (int)(cur / 2);
            carry = (int)(cur % 2);
        }
        return new BigNum(res);
    }

    public override string ToString()
    {
        StringBuilder sb = new StringBuilder();
        sb.Append(digits[digits.Count - 1]);
        for (int i = digits.Count - 2; i >= 0; i--)
            sb.Append(digits[i].ToString().PadLeft(WIDTH, '0'));
        return sb.ToString();
    }
}
/*ã€ç›®çš„ã€‘
2ã¤ã®æ•´æ•° A, B ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã€A + (A+1) + (A+2) + ... + B ã®ç·å’Œã‚’ æ­£ç¢ºã«æ±‚ã‚ãŸã„ã€‚
åˆ¶ç´„ï¼š
0 â‰¦ A â‰¦ B < 10^11
ã¤ã¾ã‚Šã€ç­”ãˆãŒ 10^19 ã‚’è¶…ãˆã‚‹å ´åˆã‚‚ã‚ã‚‹ï¼ˆulong ã‚„ long ã§ã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ï¼‰
â†’ å¤šå€é•·æ•´æ•°ï¼ˆBigNumï¼‰ã‚’è‡ªä½œã—ã¦è¨ˆç®—ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
æ•°åˆ— A ã‹ã‚‰ B ã¾ã§ã®ç·å’Œã¯ã€ä»¥ä¸‹ã®å¼ã§æ±‚ã¾ã‚Šã¾ã™ï¼š(A + B) * (B - A + 1) / 2
ã“ã‚Œã¯ã€
é …æ•°ãŒ (B - A + 1) å€‹ã‚ã‚Šå„é …ã®å¹³å‡å€¤ãŒ (A + B) / 2ã¨ã„ã†ç†ç”±ã‹ã‚‰å°ã‹ã‚Œã‚‹å…¬å¼ã§ã™ã€‚
å…¥åŠ›ã‹ã‚‰ A, B ã‚’èª­ã¿å–ã‚Šã€æ–‡å­—åˆ—ã¨ã—ã¦ BigNum ã«å¤‰æ›ã€‚count = B - A + 1ï¼ˆé …æ•°ï¼‰ sum = (A + B) * count / 2ï¼ˆç·å’Œï¼‰ æœ€çµ‚çš„ãª sum ã‚’æ–‡å­—åˆ—ã¨ã—ã¦è¡¨ç¤ºã€‚
å¤šå€é•·æ•´æ•°ã‚’ 4æ¡å˜ä½ã®é…åˆ—ï¼ˆList<int>ï¼‰ã§è¡¨ç¾ã—ã¦ãŠã‚Šã€å„æ¡ã¯ 10000 æœªæº€ã®æ•´æ•°ã¨ã—ã¾ã™ã€‚

ğŸ“¥ new BigNum("12345678") ã®ã‚ˆã†ã«ä½œã‚‹ã¨â€¦
å†…éƒ¨çš„ã«ã¯ï¼š[5678, 1234]  // ä¸‹ä½æ¡ã‹ã‚‰æ ¼ç´
C# 5.0 / Mono ç’°å¢ƒã§ã‚‚å®Œå…¨å¯¾å¿œï¼ˆBigInteger ãªã—ï¼‰
æ¡æ•°ã«åˆ¶é™ãªã—ï¼ˆç†è«–ä¸Šã¯10^100ã§ã‚‚ã„ã‘ã‚‹ï¼‰
æå‡ºç’°å¢ƒã§ 100ç‚¹ãŒå–ã‚Œã‚‹ãƒ¬ãƒ™ãƒ«ã®å …å®Ÿãªå®Ÿè£… */

<ifã‚’ä½¿ã„ã¾ã™ã‹ï¼Ÿä¸‰é …æ¼”ç®—å­ã‚’ä½¿ã„ã¾ã™ã‹ï¼Ÿ>

<æ•°ã®ä¸¦ã³æ›¿ãˆ>
